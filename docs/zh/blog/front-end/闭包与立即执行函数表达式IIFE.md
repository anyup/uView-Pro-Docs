---
title: 一文讲透JavaScript闭包与立即执行函数表达式（IIFE）
---

# 闭包与立即执行函数表达式IIFE

## 引言

闭包是一种函数的特性，用于捕获和保存其所在作用域的变量，而`IIFE`是一种用来创建函数作用域的模式。在`JavaScript`中，我们可以将闭包和`IIFE`结合使用，但它们并不是彼此依赖的概念。

虽然我们可以在`IIFE`中使用闭包，但是闭包并不依赖于`IIFE`的存在。闭包可以与任何函数一起使用，不管是普通函数还是`IIFE`。

关于闭包和`IIFE`，本文将分别讨论它们在`JavaScript`开发中的应用场景和好处。这样可以更清楚地理解它们的作用和关系，并有效地运用它们来提升代码质量和可维护性。

## 一、深入闭包的理解

![2.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ed65334c44b494ebf4e86b54859d5e2~tplv-k3u1fbpfcp-watermark.image?)

### 1.1、闭包的概念

![1.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bde9def77764033a8963c0353b53dac~tplv-k3u1fbpfcp-watermark.image?)

闭包（`closure`）是指一个函数可以访问并操作其自身作用域以外的变量。换句话说，闭包是一种能够访问其父函数作用域中的变量的函数。

在`JavaScript`中，当一个函数内部定义了另一个函数，并且内部的函数引用了外部函数的变量时，就创建了一个闭包。内部函数可以访问外部函数的变量，即使外部函数已经执行完毕，这些变量仍然可以在内部函数中使用。

闭包的一个常见用途是创建私有变量。通过使用闭包，可以在函数内部定义一个变量，使其在外部无法访问。这样可以提供更好的封装和数据隐藏。

以下是一个简单的闭包示例：

```js
function outerFunction() {
  var outerVariable = 'Hello'

  function innerFunction() {
    console.log(outerVariable)
  }

  return innerFunction
}

var closure = outerFunction()
closure() // 输出：Hello
```

在上面的例子中，`outerFunction`内部定义了`outerVariable`变量和`innerFunction`函数。`innerFunction`函数引用了`outerVariable`变量，并且作为一个闭包被返回出来。当我们调`closure`时，它保留了对`outerVariable`的引用，因此可以在执行时访问并打印出`Hello`。

### 1.2、闭包的特性

`JavaScript`之所以有闭包，是因为它采用了词法作用域的函数定义方式。

闭包的存在有以下几个重要原因：

1. **保护变量**：闭包可以创建私有变量，通过将变量封装在函数内部，外部无法直接访问，从而实现信息隐藏和保护变量的安全性

2. **实现数据封装**：闭包提供了一种封装数据的方式，在函数内部定义的变量只能在函数内部访问，外部无法修改或者获取，从而实现了数据私有化。

3. **延长变量的生命周期**：当函数执行完毕后，其作用域中的变量通常会被销毁，但是闭包可以延长变量的生命周期。内部函数仍然可以引用外部函数中的量，因此这些变量不会被垃圾回收机制销毁，可以在内部函数中继续使用。

4. **创建回调和异步操作**：闭包可以用于创建回调函数，通过将函数作为参数传递给其他函数，实现函数的延迟执行。

总的来说，闭包在`JavaScript`中具有重要的作用，可以提供更强大的编程能力，实现数据封装、变量保护、延长变量生命周期等功能。

#### 构建函数工厂

比如有这么一个场景，如何去写一个`sum(1)(2) = 3`的函数？

分析一下，`（sum(1)）(2)`显然第一个括号执行之后仍然应该是个函数，然后再把第二个参数`2`传进去。

```js
function sum(x) {
  return function (y) {
    return x + y
  }
}

sum(1)(2) // 输出结果为 3

// 问题，如果第一个数我们需要确定呢？
var add1 = sum(1)
var add2 = sum(2)

add1(5) // 输出结果为 6
add2(6) // 输出结果为 8
```

我们可以将`sum`看作是一个函数工厂，你可以用这个工厂创建出你需要的各种函数。

#### 构建私有变量

由于 ES6 之前的`JavaScript`是没有类的概念，我们用函数来模拟类。会一点`OOP`的应该都知道，有些类中的变量我们需要保护不被外界访问到，就有了私有变量的概念。

有种简单的创建类的方式如下

```
function Person() {
      this.name = 'anyup1';
      this.getName = function(){
      return this.name;
    }
 }

 var person = new Person();
 person.getName(); // 'anyup1'

 person.name = 'anyup2';
 person.getName(); // 'anyup2'
```

首先定义了一个`Person`的类构造器，实例化出一个`person`对象。但是可以直接被修改内部的变量 name，使得人的名字被修改了。我们当然不希望我们的名字被修改。

此处我们换种方式，将`name`设置为私有变量

```
 function Person() {
    var name = 'anyup';
    this.getName = function(){
       return name;
    }
 }

 var me = new Person();
 person.getName(); // 'anyup'

 person.name = 'anyup2'; // 你仍然可以设置person.name属性，但是这个对象内部的name值是保持不变的。
 person.getName(); // 'anyup'
```

分析一下，为什么说上述的是闭包呢？首先 getName 函数是包含在 Person 函数里面，但是看起来好像没有返回。我们来看下 me = new Person()做了什么，它其实是创建了一个对象，并且返回。也就是说 getName 是在此时返回的。然后 me.getName()就能使用了。

#### 变量不被回收

由于`JavaScript`的垃圾回收机制，普通函数执行完之后，变量就会被直接回收。但是，闭包的方式可以让变量一直存在，不被回收。我们来看一个简单的计数器例子。

```js
function Counter() {
  var count = 0
  return function () {
    return count++
  }
}

var counter = Counter()
counter() // 输出 0
counter() // 输出 1
```

正是由于这种变量不被回收的机制，这样我们就能实现每次执行`counter()`的时候`count`就会在原来的基础上增加 1。

### 1.3、闭包的副作用

由于`JavaScript`闭包是指函数能够访问其外部函数范围内定义的变量，即使外部函数已经执行完毕。尽管闭包在某些情况下非常有用，但它也可能带来一些副作用。

以下是一些`JavaScript`闭包可能引发的副作用：

1. **内存泄漏**：由于闭包保持对外部变量的引用，这些变量可能会一直存在于内存中，即使它们已经不再需要。如果闭包过多或闭包引用的数据过大，可能会导致内泄漏，影响程序性能。

2. **变量生命周期延长**：使用闭包可以使变量的生命周期超过它们通常在函数执行结束后被销毁的范围。这可能导致变量长时间占用内存空间，增加内存使用量。

3. **性能损失**：闭包需要维护对外部变量的引用，当闭包被频繁调用时，会增加额外的性能开销。这是因为每个闭包都需要在内存中保存对外部变量的引用，而且包访问外部变量的速度相对较慢。

出于以上原因，在编写代码时，应该谨慎使用闭包。确保确实需要使用闭包，并注意处理闭包带来的副作用。对于不再使用的闭包，及时释放相关资源，以避免内存泄漏。同时，尽量简化闭包的使用场景，以提高代码可读性和维护性。

**以下是一个简单的示例，说明闭包内存泄漏的风险：**

```js
function Person(name) {
  this.getName = function () {
    return name
  }

  this.sayHi = function () {
    alert('say Hi')
  }
}

var me = new Person('me')
var you = new Person('you')
```

上面的示例代码每创建一个对象，都有创建出一个相同的`sayHello`方法。这个方法并没有用到私有变量`name`，其实就根本不需要在`Person`内部去定义这样的一个闭包。更好的方式是将这个方法添加在`Person`的原型链上，如下图所示：
![4.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bea5c6718c044cbfae2298faf12a3050~tplv-k3u1fbpfcp-watermark.image?)

**优化后的代码如下所示：**

```
 function Person(name ) {
    this.getName = function(){
       return name;
    }
 }

  Person.prototype.sayHi = function(){
      alert("say Hi");
 }
```

### 1.4、闭包的经典场景

经典的`JavaScript`闭包应用场景中，使用闭包在`for`循环中是一个常见的例子。在循环中使用闭包可以避免变量共享和作用域问题，确保在异步操作中使用正确的值。

考虑以下示例，我们使用`for`循环创建了多个定时器，每隔一秒输出对应的数字：

```javascript
for (var i = 1; i <= 5; i++) {
  setTimeout(function () {
    console.log(i)
  }, i * 1000)
}
```

如果直接运行这段代码，你可能会期望在 1 秒后依次输出 1、2、3、4、5，但实际上输出的结果却是 6 个 6。

这是因为`setTimeout`的回调函数是在循环结束后才执行的，此时 i 已经变成了 6，所以无论定时器运行多长时间，都会输出 6。

要解决这个问题，可以利用闭包来创建一个新的作用域，捕获每次循环的变量值。我们可以通过立即执行函数表达式(IIFE)来创建闭包：

```javascript
for (var i = 1; i <= 5; i++) {
  ;(function (j) {
    setTimeout(function () {
      console.log(j)
    }, j * 1000)
  })(i)
}
```

在这个例子中，我们使用立即执行函数表达式将 i 的值传递给匿名函数的参数 j。每次循环时，都会创建一个新的作用域，保留了当前循环的变量值。

这样，每个`setTimeout`回调函数都捕获了对应的 j 值，从而实现了按照预期顺序输出 1、2、3、4、5。

通过使用闭包，我们解决了在`for`循环中使用异步操作所遇到的问题，确保了每次循环中的正确值被定时器回调函数所使用。这是一个非常常用的闭包应用场景。

## 二、深入 IIFE 的理解

### 2.1、IIFE 的概念

`IIFE`是立即执行函数表达式（`Immediately Invoked Function Expression`）的缩写。它是一种特殊的函数调用方式，也是一种用来创建函数作用域的模式。

在`JavaScrip`t 中，`IIFE`通过将函数用括号包裹，并在后面立即调用它来创建一个函数作用域。这样做的好处是可以在函数内部定义变量和函数，而不会对外部的全局作用域造成污染。

`IIFE`的基本语法如下：

```javascript
;(function () {
  // 在这里编写你的代码
})()
```

在上面的语法中，我们使用了一个匿名函数，并将其用括号包裹起来。紧接着，在括号的最后加上一对空括号，表示立即调这个函数。

### 2.2、IIFE 的特性

`IIFE`的作用包括：

1. **避免全局命名冲突**：在`IIFE`内部定义的变量和函数都是在函数作用域内，不会与全局作用域中的变量冲突。
2. **创建闭包**：`IIFE`能够捕获并保存外部作用域的变量，从而创建闭包，实现更复杂的编程技巧。
3. **封装代码**：一些库和框架通过使用`IIFE`来封装其代码，以隐藏内部的实现细节，提供干净的接口。

在模块化设计中，它是最经典的存在。如下所示：一个经典的`jQuery`插件

```js
;(function ($, window) {
  // 具体代码写在这里
})(jQuery, window, undefined)
```

### 2.3、IIFE 的经典场景

`IIFE`在`for`循环中的应用是其中一个经典的场景。在传统的`for`循环中，由于`JavaScript`中只有函数作用域和全局作用域，没有块级作用域，所以在循环体内部定义的变量会被循环体外部的代码共享，可能导致意想不到的结果。

为了解决这个问题，我们可以使用 IIFE 来创建一个立即执行的函数作用域，并在其中定义循环体内部的变量，从而避免变量共享和污染全局作用域。以下是一个简单的示例：

```javascript
for (var i = 0; i < 5; i++) {
  ;(function (j) {
    setTimeout(function () {
      console.log(j)
    }, 1000)
  })(i)
}
```

在上面的代码中，我们使用一个 IIFE 来创建一个函数作用域，并将循环变量`i`作为参数传入其中。在 IIFE 的内部，我们使用`j`来接收传入的参数`i`，这样就创建了一个函数作用域内部的变量`j`，它与外部的循环变量`i`是相互独立的。

在`IIFE`内部，我们通过`setTimeout`函数来模拟一个异步操作，将每个循环迭代的`j`的值输出到控制台。由于每个循环迭代都有一个独立的函数作用域和变量`j`，所以它们的值都可以被正确地输出。

这种使用`IIFE`的方式，在循环体内使用一个立即执行的函数作用域，可以有效避免循环变量共享和闭包问题。这在处理异步操作、事件处理等场景中非常有用。

需要注意的是，`ES6`引入了`let`和`const`关键字，它们具有块级作用域，可以直接在循环中定义新的变量，避免了使用 IIFE 的需求。所以，在使用较新版本的`JavaScript`时，可以优先考虑使用`let`或`const`来替代 IIFE 解决循环作用域的问题。

总结起来，`IIFE`在循环中的常见应用是创建函数作用域，避免循环变量的共享和污染全局作用域。它能够有效地解决传统`for`循环中的闭包问题，特别是在处理异步操作时非常实用。

## 结语

在本文中，我们详细解释了`JavaScript`闭包和立即执行函数表达式（`IIFE`）的概念、特点和用法。闭包是`JavaScript`中一个强大的特性，它可以让函数保留对其作用域外部变量的引，并且在函数执行完毕后仍然可以访问这些变量。使得我们可以创建私有变量、实现模块化和封装等功能。

然而，闭包也可能引发一些副作用，如内存泄漏和性能损失。因此，在使用闭包时，我们需要谨慎考虑其影响，并及时释放不再使用的闭包。

相对而言，`IIFE`是一种特殊的函数表达式，它可以立即执行并创建一个独立的作用。通过将代码封装在`IIFE`内部，我们防止污染全局命名空间，并且可以将变量和函数限定在私有作用域中。

在编写`JavaScript`代码时，了解闭包和`IIFE`的概念和用法，能够帮助我们更好地设计和组织代码结构，提高代码可维护性和可读性。

<ArticleFooter :link="['juejin::https://juejin.cn/post/7269744082649677835', 'weixin:https://mp.weixin.qq.com/s/OOf9i_RFixvznm_wleR5_Q']" />
