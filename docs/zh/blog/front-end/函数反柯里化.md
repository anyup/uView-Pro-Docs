---
title: 前端进阶｜看柯里化的逆操作，了解什么是反柯里化
---

# 函数反柯里化

## 温故而知新

在说反柯里化之前，先来复习下柯里化的基础。之前文章，我们了解了什么是柯里化，以及柯里化的实现原理，同时我们也明白了什么情况下我们使用柯里化，详细阅读参见之前文章[《前端进阶｜由浅入深的理解函数柯里化的实现与应用》](https://juejin.cn/post/7272364104748531731)，今天我们来了解一下反柯里化。

那什么是反柯里化呢？？是与柯里化相反吗？？

书中对反柯里化的作用做了介绍：

> 反柯里化是为了扩大函数的适用性，使本来作为特定对象所拥有的功能的函数可以被任意对象所用。

## 什么是反柯里化

### 概念

反柯里化（`Uncurrying`）是指将柯里化函数转换为接受多个参数的普通函数的过程。在函数柯里化中，一个多参数的函数被转换为接受一个参数并返回一个新函数的一系列嵌套函数。而反柯里化则是将这些嵌套函数重新组合成一个多参数的函数。

具体来说，反柯里化是将一系列通过柯里化得到的函数，重新组合成一个函数，使得这个函数能够接受与原来多参数函数相同数量的参数，并且处理这些参数。简而言之，反柯里化是将柯里化函数还原成普通函数。

### 为什么会有反柯里化

**反柯里化的意义**在于可以将柯里化函数应用于特定场景，使其更通用和灵活。通过将柯里化函数反柯里化，可以将其调用方式改变为更传统的多参数调用方式，使得函数使用更加直观和方便。这在一些需要使用多个参数的情况下特别有用。

举例说明一种常见的情况：当我们使用某个库或框架提供的函数时，这些函数可能采用柯里化的方式定义。柯里化可以使得函数的参数传递更加灵活，方便部分应用和函数组合。然而，有时候我们可能希望将这些柯里化的函数转化为普通的多参数函数，以便于更直观地使用它们，或者与其他函数进行组合。这时，反柯里化就可以派上用场。

```
// ES5 的实现
function uncurring(fn) {
    return function () {
        // 取出要执行 fn 方法的对象，同时从 arguments 中删除
        var obj = [].shift.call(arguments);
        return fn.apply(obj, arguments);
    }
}
// ES6 的实现
function uncurring(fn) {
    return function (...args) {
        return fn.call(...args);
    }
}

```

## 反柯里化的实现原理

**实现反柯里化**的关键是理解柯里化的原理和目标，以及如何将柯里化函数恢复成普通函数。

在柯里化中，一个多参数的函数被转换为接受一个参数并返回一个新函数的一系列嵌套函数。而反柯里化则是这些嵌套函数重新组合成一个多参数的函数。

下面是一种常见的实现反柯里化的思路：

1. 首先，我们考虑一个柯里化函数的特点：它接收一个参数，并返回一个新函数。
2. 我们可以通过递归遍历的方式将所有的嵌套函数都找到，并存储在一个数组中。
3. 在反柯里化时，我们需要遍历这个数组，并将每个函数的参数进行存储，直至遍历结束，得到所有的参数。
4. 最后，我们可以使用 `apply` 或 `call` 方法将原函数应用到得到的参数上，从而实现反柯里化。

一个简单的示例，说明如何实现反柯里化：

```javascript
function curry(fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn(...args);
    } else {
      return functionmoreArgs) {
        return curried(...args, ...moreArgs);
      };
    }
  };
}

function add(x) {
  return function(y) {
    return x + y;
  };
}

const curriedAdd = curry(add);

// 反柯里化
function uncurry(fn) {
  return function(...args) {
    let result = fn;
    for (let arg of args) {
      result = result(arg);
    }
    return result;
  };
}

const uncurriedAdd = uncurry(curriedAdd);
console.log(uncurriedAdd(2, 3)); // 输出 5
```

在上面的示例中，我们定义了一个柯里化函数 `curry` 和一个被柯里化的函数 `add`，然后通过应用 `curry` 函数将 `add` 函数变为柯里化函数 `curriedAdd`。最后，我们再应用反柯里化函数 `uncurry` 将 `curriedAdd` 函数还原为普通函数 `uncurriedAdd`，并且可以传递多个参数来执行。

需要注意的是，实现反柯里化的方式可能有多种，以上只是其中的一种常见实现方式。具体的实现取决于编程语言和具体的应用场景。

## 反柯里化的应用场景

反柯里化在实际开发中有着广泛的应用场景，以下是几个常见的应用场景示例：

1. **函数组合**（`Function Composition`）：在函数式编程中，函数组合是将多个函数按照一定顺序组合起来形成新的函数。反柯里化可以将柯里化函数转换为多参数函数，便于进行函数组合操作。通过将多个反柯里化的函数组合在一起，可以实现更灵活的函数组合，增加代码的可读性和模块化程度。

2. **方法调用转换**：在 `JavaScript` 中，许多内置方法（例如 `Array.prototype.map`、`Function.prototype.bind` 等）本身是柯里化的，接受一个参数并返回一个新的函数。通过将柯里化的方法调用转换为非柯里化的形式，我们可以方便地将这些方法应用于其他数据类型或实现自定义扩展方法。

3. **函数的复用**：柯里化函数可以通过分应用（`Partial Application`）的方式传递部分参数，返回一个具有更少参数的新函数。通过反柯里化，可以将部分应用的函数转换为多参数函数，从而实现函数的复用。这样可以减少重复代码，提高函数的可重用性。

例如：反柯里化在函数组合中的应用：

```javascript
function curry(fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn(...args)
    } else {
      return function (...moreArgs) {
        return curried(...args, ...moreArgs)
      }
    }
  }
}

function add(x) {
  return function (y) {
    return x + y
  }
}

function multiply(x) {
  return function (y) {
    return x * y
  }
}

const curriedAdd = curry(add)
const curriedMultiply = curry(multiply)

// 反柯里化
function uncurry(fn) {
  return function (...args) {
    let result = fn
    for (let arg of args) {
      result = result(arg)
    }
    return result
  }
}

const uncurriedAdd = uncurry(curriedAdd)
const uncurriedMultiply = uncurry(curriedMultiply)

const composed = uncurriedAdd(3) * uncurriedMultiply(2)
console.log(composed(5)) // 输出 19，相当于 (3 + 5) * (2 * 5)
```

在上面的示例中，我们定义了两个柯里化函数 `add` 和 `multiply`，然后使用 `curry` 函数将其转换为柯里化函数 `curriedAdd` 和 `curriedMultiply`。接着，我们使用反柯里化函数 `uncurry` 将这两个柯里化函数转换为非柯里化函数，并对它们进行函数组合操作。最后，通过传递参数来调用组合函数 `composed`，得到最终结果。

通过反柯里化，我们可以**将柯里化函数转换为多参数函数**，实现**函数的组合**、**复用**以及**自定义扩展**等功能，提高代码的可读性和可维护性。

## 反柯里化的优点和缺点

**反柯里化**（`Uncurrying`）在程序设计中有其优点和缺点，下面将对其进行详细说明：

优点：

1. **增加代码的可读性**：柯里化函数将一个多参数函数转换为一系列嵌套函数，使得函数调用变得复杂，阅读和理解代码可能变得困难。反柯里化可以将这些嵌套函数恢复为多参数函数，从而提高代码的可读性和理解性。

2. **提高代码的灵活性**：反柯里化将柯里化函数转换为多参数函数，使得函数的参数不再受限于事先定义的柯里化格式。这样可以更灵活地应用函数，适应不同的使用场景，提高代码的灵活性和可扩展性。

3. **函数复用和组合**：反柯里化允许对柯里化函数进行部分或完全参数应用，从而实现函数的复用和组合。通过反柯里化，我们可以更方便地将函数组合在一起，形成新的函数，提高代码的重用性和模块化程度。

缺点：

1. **额外的性能开销**：反柯里化需要进行函数的遍历和参数存储操作，可能引入一定的额外性能开销。尤其是在参数较多或嵌套函数较多的情况下，可能会对性能产生一定的影响。

2. **可读性损失**：在柯里化函数中，嵌套函数和参数的传递顺序具有一定的规律，有助于理解和调试代码。反柯里化将这些规律打破，可能增加代码的复杂性，使得阅读和理解变得更加困难。

3. **不适用于所有情况**：反柯里化并不适用于所有的函数。柯里化在某些场景下可以提供更好的代码组织和可读性，反柯里化并非总是必要的或有益的操作。

需要根据具体的应用场景和需求来决定是否使用反柯里化，并在性能和可读性之间进行权衡。在某些情况下，反柯里化可以提供更好的灵活性和代码组合能力；在另一些情况下，柯里化可能更适合保持代码的简洁性和可读性。

## 柯里化和反柯里化之间的比较

柯里化（`Currying`）和反柯里化（`Uncurrying`）是一对互逆的操作，下面是它们之间的比较：

柯里化：

1. **参数转换**：柯里化将一个**多参数函数**转换为一系列**接受部分参数的嵌套函数**，每个嵌套函数返回一个新函数，直到所有参数都被传递完。通过这种方式，柯里化函数的参数可以逐步应用，使得函数调用更加灵活和可读性更高。
2. **参数顺序**：柯里化可以改变函数参数的顺序，将原本多个参数按照特定顺序拆分成一系列的单个参数。这样可以更方便地进行函数的组合、复用和扩展，提高代码的模块化程度和可维护性。
3. **函数调用**：柯里化函数的调用方式变得更加灵活，可以逐步传递参数，允许部分参数的应用甚至跳过某些参数，符合函数式编程的思想和风格。

反柯里化：

1. **参数合并**：反柯里化将**一系列嵌套的函数**转换为**一个接受多个参数的函数**，恢复了原本多参数函数的形式。这样可以提高代码的可读性和理解性，使函数调用更加直观。
2. **参数顺序**：反柯里化可以改变函数参数的顺序，将嵌套的参数重新合并为原本的多个参数。这样可以允许对柯里化函数进行灵活调用，并与其他多参数函数进行组合和复用。
3. **函数调用**：反柯里化函数可以直接接收多个参数，并与柯里化函数相互转换。这样可以在需要多参数函数的地方使用反柯里化后的函数，简化代码的调用和维护过程。

相同点：

1. **转换形式**：柯里化和反柯里化都是一种转换函数形式的操作，将函数从一种形式转换为另一种形式，以适应不同的使用场景和需求。

不同点：

1. **参数处理**：柯里化是将多参数拆分为一系列部分参数，而反柯里化是将嵌套的部分参数合并为多参数。
2. **调用方式**：柯里化函数需要逐步传递参数直到所有参数都被传递完，而反柯里化函数可以直接接收多个参数进行调用。
3. **应用场景**：柯里化适用于需要增加灵活性和可读性的函数调用场景，反柯里化适用于需要恢复原本多参数函数形式的场景。

柯里化和反柯里化是互逆的操作，相互补充和利用，根据具体的需求和场景来选择使用柯里化或反柯里化，以提高代码的可读性、可维护性和灵活性。

<ArticleFooter :link="['juejin::https://juejin.cn/post/7273497970933448763', 'weixin::https://mp.weixin.qq.com/s/zPXpD6i1ArNs9SQS4MjQtg']" />
