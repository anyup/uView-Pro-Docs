## 问题描述

在一个班级中，每位同学都拿到了一张卡片，上面有一个整数。有趣的是，除了一个数字之外，所有的数字都恰好出现了两次。现在需要你帮助班长小 C 快速找到那个拿了独特数字卡片的同学手上的数字是什么。

### 要求：

1. 设计一个算法，使其时间复杂度为 O(n)，其中 n 是班级的人数。
2. 尽量减少额外空间的使用，以体现你的算法优化能力。

## 时间复杂度和空间复杂度

时间复杂度和空间复杂度是衡量算法效率的两个重要指标。它们帮助我们理解算法在处理不同规模输入时所需的计算资源。

### 时间复杂度

时间复杂度：描述的是算法执行时间随输入规模增长的变化趋势。它通常用大 O 表示法（Big O Notation）来表示。

**O(1)**：常数时间复杂度。无论输入规模如何，算法执行时间都是固定的。例如，访问数组中的一个元素。
**O(n)**：线性时间复杂度。算法的执行时间与输入规模成正比。例如，遍历一个数组。
**O(n^2)**：平方时间复杂度。算法的执行时间与输入规模的平方成正比。例如，嵌套循环遍历一个二维数组。
**O(log n)**：对数时间复杂度。算法的执行时间与输入规模的对数成正比。例如，二分查找。

### 空间复杂度

空间复杂度：描述的是算法在执行过程中所需的额外存储空间随输入规模增长的变化趋势。它也通常用大 O 表示法来表示。

**O(1)**：常数空间复杂度。算法所需的额外存储空间是固定的，不随输入规模变化。例如，使用几个变量。
**O(n)**：线性空间复杂度。算法所需的额外存储空间与输入规模成正比。例如，创建一个与输入规模相同的数组。
**O(n^2)**：平方空间复杂度。算法所需的额外存储空间与输入规模的平方成正比。例如，创建一个二维数组。
**O(log n)**：对数空间复杂度。算法所需的额外存储空间与输入规模的对数成正比。例如，递归调用栈。

### 示例

假设我们有一个数组 arr，长度为 n，我们想要计算数组中所有元素的和。

```js
function sumArray(arr) {
  let sum = 0
  for (let i = 0; i < arr.length; i++) {
    sum += arr[i]
  }
  return sum
}
```

- 时间复杂度：O(n)。因为我们需要遍历整个数组一次。
- 空间复杂度：O(1)。因为我们只使用了常数个额外的变量（sum 和 i）。

### 总结

- 时间复杂度关注的是算法的执行时间。
- 空间复杂度关注的是算法所需的额外存储空间。

理解这两个概念有助于我们在设计和选择算法时，更好地平衡算法的效率和资源消耗。

## 解题

使用 Set 数据结构可以有效地解决这个问题，并且时间复杂度为 O(n)，空间复杂度为 O(n)。Set 的特点是它只存储唯一的值，因此我们可以利用这个特性来找到唯一出现的数字。

### 思路

使用 Set 存储数字：遍历数组，如果数字已经在 Set 中，则将其移除；否则，将其添加到 Set 中。
最终 Set 中剩下的唯一元素：遍历结束后，Set 中剩下的唯一元素就是我们要找的数字。
优化后的代码

```js
function solution(cards) {
  const uniqueSet = new Set()

  // 遍历数组，利用 Set 的特性找到唯一出现的数字
  for (let card of cards) {
    if (uniqueSet.has(card)) {
      uniqueSet.delete(card)
    } else {
      uniqueSet.add(card)
    }
  }

  // Set 中剩下的唯一元素就是我们要找的数字
  return [...uniqueSet][0]
}

function main() {
  // Add your test cases here
  console.log(solution([1, 1, 2, 2, 3, 3, 4, 5, 5]) === 4)
  console.log(solution([0, 1, 0, 1, 2]) === 2)
}

main()
```

### 解释

**使用 Set**：

创建一个 Set 对象 uniqueSet。
遍历 cards 数组，如果当前数字已经在 Set 中，则将其移除；否则，将其添加到 Set 中。
查找唯一数字：

遍历结束后，Set 中剩下的唯一元素就是我们要找的数字。
使用扩展运算符 [...uniqueSet][0] 将 Set 转换为数组并取第一个元素。
这样，时间复杂度为 O(n)，空间复杂度为 O(n)，符合题目要求。

## 沸点

找单独的数：JavaScript 版 Set 方案
思路：由于是两两出现或单独出现的数，故使用 Set 方案
方案：遍历数组，如果数字已经在 Set 中，则将其移除；否则，将其添加到 Set 中。遍历结束后，Set 中剩下的唯一元素就是我们要找的数字。

```js
function solution(cards) {
  // 创建一个 Set
  const uniqueSet = new Set()
  // 遍历数组，利用 Set 的特性找到唯一出现的数字
  for (let card of cards) {
    // 如果已经在Set中存在就删除，如果不在就添加
    if (uniqueSet.has(card)) {
      uniqueSet.delete(card)
    } else {
      uniqueSet.add(card)
    }
  }
  // Set 中剩下的唯一元素就是我们要找的数字
  return [...uniqueSet][0]
}
```
