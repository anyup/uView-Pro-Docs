## 问题描述
### 小R从班级中抽取了一些同学，每位同学都会给出一个数字。已知在这些数字中，某个数字的出现次数超过了数字总数的一半。现在需要你帮助小R找到这个数字。

### 测试样例
样例1：

> 输入：array = [1, 3, 8, 2, 3, 1, 3, 3, 3]
输出：3

### 样例2：

> 输入：array = [5, 5, 5, 1, 2, 5, 5]
输出：5

### 样例3：

> 输入：array = [9, 9, 9, 9, 8, 9, 8, 8]
输出：9

好的，如果你想要一个更简洁的解决方案，可以使用摩尔投票算法（Boyer-Moore Voting Algorithm）。这个算法的时间复杂度为 O(n)，空间复杂度为 O(1)，非常适合解决这个问题。

摩尔投票算法思路：
初始化：设置一个候选数字 candidate 和计数器 count。
遍历数组：
如果 count 为 0，将当前数字设为 candidate。
如果当前数字等于 candidate，则 count 加 1。
如果当前数字不等于 candidate，则 count 减 1。
最终结果：遍历结束后，candidate 即为出现次数超过一半的数字。

代码实现：

```js
function solution(array) {
    let candidate = null;
    let count = 0;
    
    // 摩尔投票算法
    for (let num of array) {
        if (count === 0) {
            candidate = num;
        }
        count += (num === candidate) ? 1 : -1;
    }
    
    // 返回候选数字
    return candidate;
}

function main() {
    // Add your test cases here
    console.log(solution([1, 3, 8, 2, 3, 1, 3, 3, 3])); // 输出 3
    console.log(solution([5, 5, 5, 1, 2, 5, 5])); // 输出 5
    console.log(solution([9, 9, 9, 9, 8, 9, 8, 8])); // 输出 9
}

main();
```

关键步骤解释：
初始化：candidate 和 count 初始化为 null 和 0。
遍历数组：根据当前数字更新 candidate 和 count。
返回结果：遍历结束后，candidate 即为出现次数超过一半的数字。
这个算法非常简洁且高效，适合解决这个问题。如果有任何问题，欢迎继续提问！